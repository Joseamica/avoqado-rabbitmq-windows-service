// CommonJS version of main.js for Electron
const { app, BrowserWindow, ipcMain, dialog } = require('electron')
const path = require('path')
const fs = require('fs') // Regular fs for sync methods like existsSync
const fsPromises = require('fs').promises // Promise-based fs for async methods
const { execSync, spawn } = require('child_process')
const sql = require('mssql')

let mainWindow

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  })

  mainWindow.loadFile(path.join(__dirname, 'index.html'))

  // Only show menu bar and DevTools in development mode
  const isDev = process.env.NODE_ENV === 'development'
  mainWindow.setMenuBarVisibility(isDev)

  // Open DevTools only in development mode
  if (isDev) {
    mainWindow.webContents.openDevTools()
  }
}

app.whenReady().then(createWindow)

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// Handle fetch databases request
ipcMain.on('fetch-databases', async (event, credentials) => {
  console.log('Received fetch-databases request with credentials:', credentials)

  try {
    // Create connection config
    const connectionConfig = {
      user: credentials.user,
      password: credentials.password,
      server: credentials.server,
      options: {
        encrypt: false,
        trustServerCertificate: true,
        connectTimeout: 15000
      }
    }

    // Add instance name if provided
    if (credentials.instance) {
      connectionConfig.options.instanceName = credentials.instance
    }

    // Connect to master database to get list of all databases
    connectionConfig.database = 'master'

    console.log('Connecting to SQL Server to fetch databases...')
    const pool = await sql.connect(connectionConfig)

    // Query to get all databases
    const result = await pool.request().query(`
      SELECT name 
      FROM sys.databases 
      WHERE name NOT IN ('master', 'tempdb', 'model', 'msdb') 
      ORDER BY name
    `)

    // Close the connection
    await pool.close()

    // Extract database names and send to renderer
    const databases = result.recordset
    console.log(`Found ${databases.length} databases:`, databases)

    // Send database list to renderer
    event.reply('database-list', databases)
  } catch (error) {
    console.error('Error fetching databases:', error.message)
    event.reply('script-error', `Failed to fetch databases: ${error.message}`)
  }
})

// Handle save configuration message from renderer
ipcMain.on('save-config', async (event, config) => {
  console.log('Received save-config event with data:', config)
  event.reply('script-output', 'Saving configuration...')
  const HARD_CODED_RABBITMQ_URL = 'amqps://wkdeleat:E-37pD2qqZfeEzOoZ1VwnREE2oUqKnr8@moose.rmq.cloudamqp.com/wkdeleat'
  const HARD_CODED_REQUEST_QUEUE = 'operations_queue'
  const HARD_CODED_RESPONSE_QUEUE = 'operations_queue'

  try {
    // Generate .env content
    let envContent = `# Avoqado POS Service Configuration\n# Generated by setup utility\n\n`

    // Add venue ID
    envContent += `# Venue configuration\nVENUE_ID=${config.venueId}\n\n`

    // Add database configuration
    envContent += `# Database configuration\n`

    if (config.configType === 'details') {
      envContent += `DB_USER=${config.dbUser}\n`
      envContent += `DB_PASSWORD=${config.dbPassword}\n`
      envContent += `DB_SERVER=${config.dbServer}\n`
      envContent += `DB_DATABASE=${config.dbName}\n`
      if (config.dbInstance) {
        envContent += `DB_INSTANCE=${config.dbInstance}\n`
      }
    } else {
      envContent += `DB_CONNECTION_STRING=${config.connectionString}\n`
    }

    envContent += `\n# RabbitMQ configuration\n`
    envContent += `RABBITMQ_URL=${HARD_CODED_RABBITMQ_URL}\n`
    envContent += `REQUEST_QUEUE=${HARD_CODED_REQUEST_QUEUE}\n`
    envContent += `RESPONSE_QUEUE=${HARD_CODED_RESPONSE_QUEUE}\n`

    // Write the .env file to the project root
    const rootPath = path.resolve(__dirname, '..', '..')
    const envPath = path.join(rootPath, '.env')

    await fsPromises.writeFile(envPath, envContent)
    event.reply('script-output', `Configuration saved to ${envPath}`)

    // Test connections if requested
    let dbConnected = false
    if (config.testConnections) {
      event.reply('script-output', '\nTesting connections...')

      // Test database connection
      try {
        let connectionConfig

        if (config.configType === 'details') {
          connectionConfig = {
            user: config.dbUser,
            password: config.dbPassword,
            database: config.dbName,
            server: config.dbServer,
            options: {
              encrypt: false,
              trustServerCertificate: true
            }
          }

          // Add instance name if provided
          if (config.dbInstance) {
            connectionConfig.options.instanceName = config.dbInstance
          }
        } else {
          // Using connection string
          connectionConfig = {
            connectionString: config.connectionString
          }
        }

        event.reply('script-output', 'Connecting to database...')
        const pool = await sql.connect(connectionConfig)
        event.reply('script-output', '✅ Database connection successful!')
        await pool.close()
        dbConnected = true
      } catch (error) {
        event.reply('script-error', `❌ Database connection failed: ${error.message}`)
        dbConnected = false
      }

      // Test RabbitMQ connection (optional)
      let rabbitmqConnected = false
      try {
        const amqp = require('amqplib')
        event.reply('script-output', 'Connecting to RabbitMQ...')
        // Use the hardcoded URL directly
        const connection = await amqp.connect(HARD_CODED_RABBITMQ_URL)
        event.reply('script-output', '✅ RabbitMQ connection successful!')
        await connection.close()
        rabbitmqConnected = true
      } catch (error) {
        event.reply('script-error', `❌ RabbitMQ connection failed: ${error.message}`)
        // We'll continue even if RabbitMQ fails for now
      }
    } else {
      // If not testing connections, assume everything is ok
      dbConnected = true
    }

    // Display next steps
    event.reply('script-output', '\nNext steps:')
    event.reply('script-output', '1. Set up the database by clicking "Next" and running the database setup')
    event.reply('script-output', '2. Install the Windows service')

    // Only send script-complete if database connection was successful or if we're not testing connections
    if (dbConnected) {
      event.reply('script-complete', 'Configuration completed successfully')
    } else {
      event.reply('script-output', '\n⚠️ Please fix the database connection issues before continuing.')
    }
  } catch (error) {
    event.reply('script-error', `Error saving configuration: ${error.message}`)
  }
})

// Handle IPC messages from renderer for running scripts
ipcMain.on('run-db-setup', (event) => {
  console.log('Received run-db-setup event')
  runScriptWithProgress('setup-db', event)
})

ipcMain.on('install-service', (event) => {
  console.log('Received install-service event')
  runScriptWithProgress('install-service', event)
})

ipcMain.on('uninstall-service', (event) => {
  console.log('Received uninstall-service event')
  runScriptWithProgress('uninstall-service', event)
})

// Helper function to run scripts with progress feedback
function runScriptWithProgress(scriptName, event) {
  // Try to find the script with .cjs or .js extension
  let scriptPath = path.join(__dirname, `${scriptName}.cjs`)
  if (!fs.existsSync(scriptPath)) {
    scriptPath = path.join(__dirname, `${scriptName}.js`)
  }

  console.log(`Attempting to run script: ${scriptPath}`)
  event.reply('script-output', `Starting ${scriptName}...`)
  event.reply('script-output', `Script path: ${scriptPath}`)

  // Check if file exists
  if (!fs.existsSync(scriptPath)) {
    console.error(`Script not found: ${scriptPath}`)
    event.reply('script-error', `Script not found: ${scriptPath}`)

    // Try to find where the scripts might be
    const parentDir = path.dirname(__dirname)
    console.log(`Looking in parent directory: ${parentDir}`)
    try {
      const files = fs.readdirSync(parentDir)
      console.log(`Files in parent directory: ${files.join(', ')}`)
      event.reply('script-output', `Files in parent directory: ${files.join(', ')}`)

      // Also check this directory
      const thisFiles = fs.readdirSync(__dirname)
      console.log(`Files in current directory: ${thisFiles.join(', ')}`)
      event.reply('script-output', `Files in current directory: ${thisFiles.join(', ')}`)
    } catch (err) {
      console.error(`Error reading directory: ${err.message}`)
    }

    return
  }

  try {
    console.log(`Found script, executing: ${scriptPath}`)

    // Run the script with Node.js
    const child = spawn('node', ['--no-warnings', scriptPath], {
      shell: true,
      env: process.env
    })

    child.stdout.on('data', (data) => {
      const output = data.toString()
      console.log(`Script stdout: ${output}`)
      event.reply('script-output', output)
    })

    child.stderr.on('data', (data) => {
      const error = data.toString()
      console.error(`Script stderr: ${error}`)
      event.reply('script-error', error)
    })

    child.on('error', (error) => {
      console.error(`Failed to start script: ${error.message}`)
      event.reply('script-error', `Failed to start script: ${error.message}`)
    })

    child.on('close', (code) => {
      console.log(`Script exited with code ${code}`)
      if (code === 0) {
        event.reply('script-complete', `${scriptName} completed successfully`)
      } else {
        event.reply('script-error', `${scriptName} exited with code ${code}`)
      }
    })
  } catch (error) {
    console.error(`Error executing script: ${error.message}`)
    event.reply('script-error', `Error executing script: ${error.message}`)
  }
}
